#!/bin/bash
# xcb - Xcode build, test, and run from the terminal
# https://github.com/bentford/xcb
# Copyright (c) 2026 Ben Ford
# Licensed under the MIT License. See LICENSE for details.

set -uo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

require_xcbeautify() {
    if ! command -v xcbeautify &>/dev/null; then
        echo -e "${RED}Error: xcbeautify is not installed${NC}"
        echo -e "${YELLOW}Install with: brew install xcbeautify${NC}"
        exit 1
    fi
}

# Show a post-build summary of warnings, errors, and (optionally) test failures.
# Pass "true" as $2 to include test results in the summary.
show_error_summary() {
    local build_log="$1"
    local include_tests="${2:-false}"
    local summary
    if [[ "$include_tests" == true && "$GREP_ERRORS" == true ]]; then
        # Extract only failure lines from the raw log.
        # ‚úò = Swift Testing failures; ": error: -[" = XCTest assertion failures
        summary=$(grep -E '‚úò |: error: -\[' "$build_log" | head -50)
    elif [[ "$include_tests" == true ]]; then
        summary=$(xcbeautify --quiet --is-ci < "$build_log")
    else
        summary=$(xcbeautify --quiet < "$build_log")
    fi
    summary=$(echo "$summary" | sed '/^[[:space:]]*$/d')
    if [[ -n "$summary" ]]; then
        echo ""
        echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        echo "$summary"
        echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    fi
}

# Default values (set via 'select' commands or CLI flags; saved in .xcbrc)
WORKSPACE=""
IPHONE_NAME=""
OS_VERSION=""
SCHEME=""
ACTION=""
SUB_ACTION=""
SKIP_BUILD=false
DETAILED=false
ONLY_TEST=""
FORCE=false
FILTER=""
FILTER_SCHEME=false
DRY_RUN=false
CLEAN=false
AUDIBLE=false
GREP_ERRORS=false

# Load saved defaults from .xcbrc
XCB_CONFIG=".xcbrc"
if [[ -f "$XCB_CONFIG" ]]; then
    source "$XCB_CONFIG"
fi

usage() {
    echo "Usage: $0 <action> [sub-action] -s <scheme> [options...]"
    echo ""
    echo "Actions:"
    echo "  select workspace       Pick default Xcode workspace"
    echo "  select scheme          Pick default scheme from workspace"
    echo "  select iphone          Pick default iPhone simulator"
    echo "  setup                  Select workspace, scheme, and simulator"
    echo ""
    echo "  clean                  Clean derived data for scheme"
    echo "  build                  Build only"
    echo "  build run              Build and run app in simulator"
    echo "  run                    Run last built app in simulator (no build)"
    echo ""
    echo "  test                   Build and run tests"
    echo "  test coverage          Build and run tests with code coverage report"
    echo ""
    echo "  purge                  Remove coverage files from /tmp"
    echo ""
    echo "Options:"
    echo "  -s, --scheme <name>    Xcode scheme (${SCHEME:-not set, use 'select scheme'})"
    echo "  -w, --workspace <path> Xcode workspace (${WORKSPACE:-not set, use 'select workspace'})"
    echo "  -i, --iphone <name>    iPhone simulator name (${IPHONE_NAME:-not set, use 'select iphone'})"
    echo "  -o, --os-version <ver> iOS version (${OS_VERSION:-not set, use 'select iphone'})"
    echo "  --only <test>          Run specific test(s) (test actions only)"
    echo "                         Format: TestTarget/TestClass[/testMethod]"
    echo "  --skip-build           Skip build, use results from last run (test coverage)"
    echo "  --detailed             File-level coverage breakdown (test coverage)"
    echo "  --clean                Clean before building (build actions only)"
    echo "  --filter <text>        Filter by text (select scheme, test coverage)"
    echo "  --filter-scheme        Filter coverage targets by scheme name"
    echo "  --dry-run              Show the command without running it"
    echo "  -a, --audible          Play a sound when the command finishes"
    echo "  --grep-errors          Grep raw log for errors instead of using xcbeautify"
    echo "  --force                Skip confirmation (purge only)"
    echo "  -h, --help             Show this help"
    echo ""
    echo "Examples:"
    echo "  $0 select workspace            Pick a default workspace"
    echo "  $0 select scheme              Pick a default scheme"
    echo "  $0 select iphone              Pick a default simulator"
    echo "  $0 test -s MyScheme"
    echo "  $0 test -s MyScheme --only MyTests/MyTestClass"
    echo "  $0 test coverage -s MyScheme --detailed"
    echo "  $0 test coverage --skip-build -s MyScheme"
    echo "  $0 build -s MyApp"
    echo "  $0 build run -s MyApp"
    echo "  $0 run -s MyApp"
    echo "  $0 setup                       Interactive setup (workspace, scheme, simulator)"
    echo "  $0 purge --force"
    exit 1
}

# Function: Find most recent xcresult in /tmp, current directory, or DerivedData
find_most_recent_xcresult() {
    local filter_name="${1:-}"
    local derived_data="$HOME/Library/Developer/Xcode/DerivedData"
    local best_match=""
    local best_time=0

    # Helper: update best match if xcresult passes filter and is newer
    check_xcresult() {
        local xcresult="$1"
        local mod_time
        if [[ "$OSTYPE" == "darwin"* ]]; then
            mod_time=$(stat -f %m "$xcresult" 2>/dev/null || echo 0)
        else
            mod_time=$(stat -c %Y "$xcresult" 2>/dev/null || echo 0)
        fi

        if [[ -n "$filter_name" ]]; then
            local xcresult_name
            xcresult_name=$(basename "$xcresult")
            if [[ "$xcresult_name" != *"$filter_name"* ]]; then
                return
            fi
        fi

        if [[ $mod_time -gt $best_time ]]; then
            best_match="$xcresult"
            best_time=$mod_time
        fi
    }

    # Search /tmp first (where test/coverage actions now write results)
    while IFS= read -r xcresult; do
        check_xcresult "$xcresult"
    done < <(find -L /tmp -maxdepth 1 -name "*.xcresult" -type d 2>/dev/null)

    # Search current directory
    while IFS= read -r xcresult; do
        check_xcresult "$xcresult"
    done < <(find . -maxdepth 1 -name "*.xcresult" -type d 2>/dev/null)

    # Fall back to DerivedData if nothing found yet
    if [[ -z "$best_match" && -d "$derived_data" ]]; then
        while IFS= read -r xcresult; do
            check_xcresult "$xcresult"
        done < <(find "$derived_data" -name "*.xcresult" -type d 2>/dev/null | head -n 50)
    fi

    echo "$best_match"
}

# Function: Extract coverage data using xccov
extract_coverage() {
    local xcresult_path="$1"

    if ! xcrun --find xccov &> /dev/null; then
        echo -e "${RED}‚úó xccov command not found${NC}" >&2
        echo -e "${YELLOW}Make sure Xcode is installed (xccov requires full Xcode, not just Command Line Tools).${NC}" >&2
        return 1
    fi

    xcrun xccov view --report --json "$xcresult_path" 2>/dev/null
}

# Function: Format coverage summary
format_summary() {
    local json_data="$1"
    local xcresult_path="$2"
    local filter="${3:-}"

    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}‚ö† jq not installed. Install with: brew install jq${NC}"
        echo "$json_data"
        return
    fi

    local targets
    if [[ -n "$filter" ]]; then
        targets=$(echo "$json_data" | jq -r --arg f "$filter" '.targets[] | select(.executableLines > 0) | select(.name | contains($f)) | .name')
        # Fall back to all targets if filter matches nothing
        if [[ -z "$targets" ]]; then
            echo -e "${YELLOW}‚ö† No targets matching '$filter', showing all${NC}"
            targets=$(echo "$json_data" | jq -r '.targets[] | select(.executableLines > 0) | .name')
        fi
    else
        # Show all targets with executable lines (excludes empty stubs/headers)
        targets=$(echo "$json_data" | jq -r '.targets[] | select(.executableLines > 0) | .name')
    fi

    echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${BOLD}üìä CODE COVERAGE REPORT${NC}"
    echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}\n"

    echo -e "${CYAN}üì¶ xcresult:${NC} $(basename "$xcresult_path")"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        mod_date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$xcresult_path" 2>/dev/null)
        echo -e "${CYAN}üìÖ Modified:${NC} $mod_date"
    fi
    echo ""

    while IFS= read -r target; do
        local coverage
        coverage=$(echo "$json_data" | jq -r ".targets[] | select(.name == \"$target\") | .lineCoverage")

        local covered_lines
        covered_lines=$(echo "$json_data" | jq -r ".targets[] | select(.name == \"$target\") | .coveredLines")

        local executable_lines
        executable_lines=$(echo "$json_data" | jq -r ".targets[] | select(.name == \"$target\") | .executableLines")

        local files_count
        files_count=$(echo "$json_data" | jq -r ".targets[] | select(.name == \"$target\") | .files | length")

        local coverage_percent
        coverage_percent=$(echo "$coverage * 100" | bc -l | xargs printf "%.4f")

        local color="$GREEN"
        if (( $(echo "$coverage < 0.8" | bc -l) )); then
            color="$YELLOW"
        fi
        if (( $(echo "$coverage < 0.6" | bc -l) )); then
            color="$RED"
        fi

        echo -e "${BOLD}Target:${NC} $target"
        echo -e "  ${BOLD}Line Coverage:${NC}    ${color}${coverage_percent}%${NC}"
        echo -e "  ${BOLD}Covered Lines:${NC}    $covered_lines / $executable_lines"
        echo -e "  ${BOLD}Files:${NC}            $files_count"
        echo ""
    done <<< "$targets"

    echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
}

# Function: Format detailed output with file-level breakdown
format_detailed() {
    local json_data="$1"
    local filter="${2:-}"

    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}‚ö† Detailed output requires jq. Please install: brew install jq${NC}"
        return 1
    fi

    echo -e "\n${BOLD}üìÅ File-Level Coverage:${NC}\n"

    local files
    if [[ -n "$filter" ]]; then
        files=$(echo "$json_data" | jq -r --arg f "$filter" '.targets[] | select(.executableLines > 0) | select(.name | contains($f)) | .files[] | "\(.lineCoverage)|\(.name)|\(.coveredLines)|\(.executableLines)"' | sort -t'|' -k1 -rn)
        # Fall back to all targets if filter matches nothing
        if [[ -z "$files" ]]; then
            files=$(echo "$json_data" | jq -r '.targets[] | select(.executableLines > 0) | .files[] | "\(.lineCoverage)|\(.name)|\(.coveredLines)|\(.executableLines)"' | sort -t'|' -k1 -rn)
        fi
    else
        # Show files from all targets with executable lines
        files=$(echo "$json_data" | jq -r '.targets[] | select(.executableLines > 0) | .files[] | "\(.lineCoverage)|\(.name)|\(.coveredLines)|\(.executableLines)"' | sort -t'|' -k1 -rn)
    fi

    echo -e "${BOLD}Top 10 Files (Best Coverage):${NC}"
    echo "$files" | head -10 | while IFS='|' read -r coverage name covered executable; do
        coverage_percent=$(echo "$coverage * 100" | bc -l | xargs printf "%.4f")
        filename=$(basename "$name")
        echo -e "  ${GREEN}‚úì${NC} ${filename}"
        echo -e "    ${coverage_percent}%  (${covered}/${executable} lines)"
    done

    echo -e "\n${BOLD}Bottom 10 Files (Need Attention):${NC}"
    echo "$files" | tail -10 | tac | while IFS='|' read -r coverage name covered executable; do
        coverage_percent=$(echo "$coverage * 100" | bc -l | xargs printf "%.4f")
        filename=$(basename "$name")

        local color="$YELLOW"
        if (( $(echo "$coverage < 0.3" | bc -l) )); then
            color="$RED"
        fi

        echo -e "  ${color}‚ö†${NC} ${filename}"
        echo -e "    ${coverage_percent}%  (${covered}/${executable} lines)"
    done

    echo ""
}

# Parse positional arguments (action and sub-action)
if [[ $# -gt 0 && "$1" != -* ]]; then
    case "$1" in
        build|test|run|clean|purge|select|setup)
            ACTION="$1"; shift
            if [[ $# -gt 0 && "$1" != -* ]]; then
                case "$ACTION" in
                    test)
                        if [[ "$1" == "coverage" ]]; then
                            SUB_ACTION="$1"; shift
                        else
                            echo "Error: Unknown test sub-action '$1'"; usage
                        fi
                        ;;
                    build)
                        if [[ "$1" == "run" ]]; then
                            SUB_ACTION="$1"; shift
                        else
                            echo "Error: Unknown build sub-action '$1'"; usage
                        fi
                        ;;
                    select)
                        if [[ "$1" == "workspace" || "$1" == "scheme" || "$1" == "iphone" ]]; then
                            SUB_ACTION="$1"; shift
                        else
                            echo "Error: Unknown select sub-action '$1'"; usage
                        fi
                        ;;
                    run|clean|purge|setup)
                        echo "Error: '$ACTION' does not take a sub-action"; usage
                        ;;
                esac
            fi
            ;;
    esac
fi
[[ -z "$ACTION" ]] && usage

# Parse flags
while [[ $# -gt 0 ]]; do
    case $1 in
        -s|--scheme)
            SCHEME="$2"
            shift 2
            ;;
        -w|--workspace)
            WORKSPACE="$2"
            shift 2
            ;;
        -i|--iphone)
            IPHONE_NAME="$2"
            shift 2
            ;;
        -o|--os-version)
            OS_VERSION="$2"
            shift 2
            ;;
        --detailed)
            DETAILED=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --filter)
            FILTER="$2"
            shift 2
            ;;
        --filter-scheme)
            FILTER_SCHEME=true
            shift
            ;;
        --clean)
            CLEAN=true
            shift
            ;;
        -a|--audible)
            AUDIBLE=true
            shift
            ;;
        --grep-errors)
            GREP_ERRORS=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-build)
            SKIP_BUILD=true
            shift
            ;;
        --only)
            ONLY_TEST="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Map action + sub-action to internal action name
case "$ACTION" in
    build) [[ "$SUB_ACTION" == "run" ]] && ACTION="build-run" ;;
    test)
        case "$SUB_ACTION" in
            coverage) ACTION="coverage" ;;
            "") ;; # stays "test"
            *)  echo "Error: Unknown test sub-action '$SUB_ACTION'"; usage ;;
        esac
        ;;
    select)
        if [[ -z "$SUB_ACTION" ]]; then
            echo "Error: 'select' requires a sub-action (scheme or iphone)"; usage
        fi
        ;;
    clean|run|purge|setup) ;;
    *) echo "Error: Unknown action '$ACTION'"; usage ;;
esac

# Select action - pick default workspace, scheme, or iPhone simulator
if [[ "$ACTION" == "select" ]]; then
    if [[ "$SUB_ACTION" == "workspace" ]]; then
        workspaces=$(find . -maxdepth 1 -name "*.xcworkspace" -type d 2>/dev/null | sed 's|^\./||' | sort)

        if [[ -z "$workspaces" ]]; then
            echo -e "${RED}Error: No .xcworkspace found in current directory${NC}"
            exit 1
        fi

        echo ""
        echo -e "${BOLD}Available workspaces:${NC}"
        i=1
        while IFS= read -r ws; do
            if [[ "$ws" == "$WORKSPACE" ]]; then
                echo -e "  ${GREEN}$i) $ws (current)${NC}"
            else
                echo "  $i) $ws"
            fi
            (( i++ ))
        done <<< "$workspaces"

        echo ""
        total=$(echo "$workspaces" | wc -l | tr -d ' ')
        printf "${CYAN}Pick a workspace [1-$total]:${NC} "
        read -r choice

        if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$total" ]]; then
            echo -e "${RED}Invalid selection${NC}"
            exit 1
        fi

        selected=$(echo "$workspaces" | sed -n "${choice}p")

        # Write or update WORKSPACE in config file
        if [[ -f "$XCB_CONFIG" ]] && grep -q '^WORKSPACE=' "$XCB_CONFIG"; then
            sed -i '' "s|^WORKSPACE=.*|WORKSPACE=\"$selected\"|" "$XCB_CONFIG"
        else
            echo "WORKSPACE=\"$selected\"" >> "$XCB_CONFIG"
        fi

        echo -e "${GREEN}Default workspace set to: ${BOLD}$selected${NC}"

    elif [[ "$SUB_ACTION" == "scheme" ]]; then
        if [[ -z "$WORKSPACE" ]]; then
            echo -e "${RED}Error: Workspace is not set${NC}"
            echo -e "${YELLOW}Tip: Run '$0 select workspace' first${NC}"
            exit 1
        fi
        echo -e "${BLUE}Fetching schemes from $WORKSPACE (resolving packages)...${NC}"
        schemes=$(xcodebuild -workspace "$WORKSPACE" -list 2>/dev/null | sed -n '/Schemes:/,/^$/p' | tail -n +2 | sed '/^$/d' | sed 's/^[[:space:]]*//')

        if [[ -n "$FILTER" ]]; then
            schemes=$(echo "$schemes" | grep -i "$FILTER")
            if [[ -z "$schemes" ]]; then
                echo -e "${RED}Error: No schemes matching '$FILTER' found in $WORKSPACE${NC}"
                exit 1
            fi
            echo -e "${CYAN}Filtered by:${NC} $FILTER"
        elif [[ -z "$schemes" ]]; then
            echo -e "${RED}Error: No schemes found in $WORKSPACE${NC}"
            exit 1
        fi

        echo ""
        echo -e "${BOLD}Available schemes:${NC}"
        i=1
        while IFS= read -r scheme; do
            if [[ "$scheme" == "${SCHEME:-}" ]]; then
                echo -e "  ${GREEN}$i) $scheme (current)${NC}"
            else
                echo "  $i) $scheme"
            fi
            (( i++ ))
        done <<< "$schemes"

        echo ""
        total=$(echo "$schemes" | wc -l | tr -d ' ')
        printf "${CYAN}Pick a scheme [1-$total]:${NC} "
        read -r choice

        if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$total" ]]; then
            echo -e "${RED}Invalid selection${NC}"
            exit 1
        fi

        selected=$(echo "$schemes" | sed -n "${choice}p")

        # Write or update SCHEME in config file
        if [[ -f "$XCB_CONFIG" ]] && grep -q '^SCHEME=' "$XCB_CONFIG"; then
            sed -i '' "s/^SCHEME=.*/SCHEME=\"$selected\"/" "$XCB_CONFIG"
        else
            echo "SCHEME=\"$selected\"" >> "$XCB_CONFIG"
        fi

        echo -e "${GREEN}Default scheme set to: ${BOLD}$selected${NC}"

    elif [[ "$SUB_ACTION" == "iphone" ]]; then
        echo -e "${BLUE}Fetching available iPhone simulators...${NC}"

        # Parse simctl output to get device name + OS version pairs
        # Section headers look like: "-- iOS 26.2 --"
        # Device lines look like:   "    iPhone 17 (UUID) (Booted)"
        simulators=()
        current_os=""
        while IFS= read -r line; do
            if [[ "$line" =~ ^--\ iOS\ (.+)\ --$ ]]; then
                current_os="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^[[:space:]]+iPhone ]]; then
                name=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/ ([A-F0-9-]*)//' | sed 's/ (Booted)//' | sed 's/ (Shutdown)//' | sed 's/[[:space:]]*$//')
                simulators+=("${name}|${current_os}")
            fi
        done < <(xcrun simctl list devices available)

        if [[ ${#simulators[@]} -eq 0 ]]; then
            echo -e "${RED}Error: No iPhone simulators found${NC}"
            exit 1
        fi

        echo ""
        echo -e "${BOLD}Available iPhone simulators:${NC}"
        i=1
        for entry in "${simulators[@]}"; do
            sim_name="${entry%%|*}"
            sim_os="${entry##*|}"
            current_marker=""
            if [[ "$sim_name" == "${IPHONE_NAME:-}" && "$sim_os" == "${OS_VERSION:-}" ]]; then
                current_marker=" ${GREEN}(current)${NC}"
            fi
            echo -e "  $i) ${sim_name} (iOS ${sim_os})${current_marker}"
            (( i++ ))
        done

        echo ""
        total=${#simulators[@]}
        printf "${CYAN}Pick a simulator [1-$total]:${NC} "
        read -r choice

        if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$total" ]]; then
            echo -e "${RED}Invalid selection${NC}"
            exit 1
        fi

        selected="${simulators[$((choice - 1))]}"
        selected_name="${selected%%|*}"
        selected_os="${selected##*|}"

        # Write or update IPHONE_NAME in config file
        if [[ -f "$XCB_CONFIG" ]] && grep -q '^IPHONE_NAME=' "$XCB_CONFIG"; then
            sed -i '' "s/^IPHONE_NAME=.*/IPHONE_NAME=\"$selected_name\"/" "$XCB_CONFIG"
        else
            echo "IPHONE_NAME=\"$selected_name\"" >> "$XCB_CONFIG"
        fi

        # Write or update OS_VERSION in config file
        if [[ -f "$XCB_CONFIG" ]] && grep -q '^OS_VERSION=' "$XCB_CONFIG"; then
            sed -i '' "s/^OS_VERSION=.*/OS_VERSION=\"$selected_os\"/" "$XCB_CONFIG"
        else
            echo "OS_VERSION=\"$selected_os\"" >> "$XCB_CONFIG"
        fi

        echo -e "${GREEN}Default simulator set to: ${BOLD}$selected_name${NC} ${GREEN}(iOS $selected_os)${NC}"
    fi

    exit 0
fi

# Setup action - run all select sub-actions in sequence
if [[ "$ACTION" == "setup" ]]; then
    "$0" select workspace || exit $?
    "$0" select scheme || exit $?
    "$0" select iphone || exit $?
    exit 0
fi

# Purge action - remove xcresult bundles from /tmp
if [[ "$ACTION" == "purge" ]]; then
    result_list=$(find -L /tmp -maxdepth 1 -name "*.xcresult" -type d 2>/dev/null | sort)

    if [[ -z "$result_list" ]]; then
        echo -e "${GREEN}‚úì No .xcresult bundles found in /tmp${NC}"
        exit 0
    fi

    echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${BOLD}üóë  PURGE .xcresult bundles from /tmp${NC}"
    echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}\n"

    count=0
    while IFS= read -r result; do
        size=$(du -sh "$result" 2>/dev/null | awk '{print $1}')
        echo -e "  ${YELLOW}‚Üí${NC} $(basename "$result")  ${CYAN}(${size})${NC}"
        (( count++ ))
    done <<< "$result_list"

    echo ""
    echo -e "  Found ${BOLD}${count}${NC} bundle(s)"
    echo ""

    if [[ "$FORCE" == false ]]; then
        printf "${YELLOW}Remove all of the above? [y/N]${NC} "
        read -r confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo -e "${YELLOW}Cancelled.${NC}"
            exit 0
        fi
    fi

    removed=0
    while IFS= read -r result; do
        if rm -rf "$result"; then
            (( removed++ ))
        else
            echo -e "${RED}‚úó Failed to remove: $result${NC}"
        fi
    done <<< "$result_list"

    echo -e "${GREEN}‚úÖ Removed $removed bundle(s) from /tmp${NC}"
    echo -e "${BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    exit 0
fi

# Warn if --only is used with non-test actions
if [[ -n "$ONLY_TEST" && "$ACTION" != "test" && "$ACTION" != "coverage" ]] || \
   [[ -n "$ONLY_TEST" && "$SKIP_BUILD" == true ]]; then
    echo -e "${YELLOW}‚ö† --only is ignored in $ACTION action${NC}"
    ONLY_TEST=""
fi

if [[ "$ACTION" == "coverage" && "$SKIP_BUILD" == true ]]; then
    if [[ "$DRY_RUN" != true ]]; then
        echo -e "${BLUE}üîç Searching for most recent .xcresult...${NC}"
        XCRESULT_PATH=$(find_most_recent_xcresult "${SCHEME:-}")
        if [[ -z "$XCRESULT_PATH" ]]; then
            echo -e "${RED}Error: No .xcresult found in current directory or DerivedData${NC}"
            echo -e "${YELLOW}Tip: Run tests with coverage first${NC}"
            exit 1
        fi
        echo -e "${GREEN}‚úì Found: $(basename "$XCRESULT_PATH")${NC}"
    fi
elif [[ -z "${SCHEME:-}" ]]; then
    echo -e "${RED}Error: Scheme is required${NC}"
    echo -e "${YELLOW}Tip: Run '$0 select scheme' or pass -s <scheme>${NC}"
    exit 1
fi

if [[ "$SKIP_BUILD" != true ]]; then
    # Validate required settings for actions that need a simulator
    if [[ -z "$WORKSPACE" ]]; then
        echo -e "${RED}Error: Workspace is not set${NC}"
        echo -e "${YELLOW}Tip: Run '$0 select workspace' or pass -w <workspace>${NC}"
        exit 1
    fi
    if [[ -z "$IPHONE_NAME" ]]; then
        echo -e "${RED}Error: iPhone simulator is not set${NC}"
        echo -e "${YELLOW}Tip: Run '$0 select iphone' or pass -i <name> -o <version>${NC}"
        exit 1
    fi
    if [[ -z "$OS_VERSION" ]]; then
        echo -e "${RED}Error: iOS version is not set${NC}"
        echo -e "${YELLOW}Tip: Run '$0 select iphone' or pass -o <version>${NC}"
        exit 1
    fi

    # Build destination string
    DESTINATION="platform=iOS Simulator,name=${IPHONE_NAME},OS=${OS_VERSION}"
fi

play_sound() {
    if [[ "$AUDIBLE" != true ]]; then
        return
    fi
    if ! command -v afplay &>/dev/null; then
        return
    fi
    local sound_file
    if [[ "$1" -eq 0 ]]; then
        sound_file="/System/Library/Sounds/Glass.aiff"
    else
        sound_file="/System/Library/Sounds/Basso.aiff"
    fi
    afplay "$sound_file" &>/dev/null &
}

# Clean action - clean derived data for scheme
if [[ "$ACTION" == "clean" ]]; then
    echo "Cleaning: $SCHEME"
    echo "   Workspace: $WORKSPACE"
    echo ""

    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}xcodebuild clean \\${NC}"
        echo -e "${YELLOW}    -workspace \"$WORKSPACE\" \\${NC}"
        echo -e "${YELLOW}    -scheme \"$SCHEME\" \\${NC}"
        echo -e "${YELLOW}    -destination \"$DESTINATION\"${NC}"
        exit 0
    fi

    xcodebuild clean \
        -workspace "$WORKSPACE" \
        -scheme "$SCHEME" \
        -destination "$DESTINATION" \
        2>&1 | tail -1
    CLEAN_STATUS=${PIPESTATUS[0]}

    if [[ $CLEAN_STATUS -ne 0 ]]; then
        echo -e "${RED}Clean failed (exit code: $CLEAN_STATUS)${NC}"
        play_sound $CLEAN_STATUS
        exit $CLEAN_STATUS
    fi
    echo -e "${GREEN}Clean succeeded${NC}"
    play_sound 0
    exit 0
fi

# Build action - build only
if [[ "$ACTION" == "build" ]]; then
    echo "Building: $SCHEME"
    echo "   Workspace: $WORKSPACE"
    echo "   Simulator: $IPHONE_NAME (iOS $OS_VERSION)"
    if [[ "$CLEAN" == true ]]; then
        echo "   Clean: yes"
    fi
    echo ""

    if [[ "$DRY_RUN" == true ]]; then
        if [[ "$CLEAN" == true ]]; then
            echo -e "${YELLOW}xcodebuild clean \\${NC}"
            echo -e "${YELLOW}    -workspace \"$WORKSPACE\" \\${NC}"
            echo -e "${YELLOW}    -scheme \"$SCHEME\" \\${NC}"
            echo -e "${YELLOW}    -destination \"$DESTINATION\"${NC}"
            echo ""
        fi
        echo -e "${YELLOW}xcodebuild build \\${NC}"
        echo -e "${YELLOW}    -workspace \"$WORKSPACE\" \\${NC}"
        echo -e "${YELLOW}    -scheme \"$SCHEME\" \\${NC}"
        echo -e "${YELLOW}    -destination \"$DESTINATION\" \\${NC}"
        echo -e "${YELLOW}    2>&1 | xcbeautify${NC}"
        exit 0
    fi

    require_xcbeautify

    if [[ "$CLEAN" == true ]]; then
        echo -e "${BLUE}Cleaning...${NC}"
        xcodebuild clean \
            -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -destination "$DESTINATION" \
            2>&1 | tail -1
        if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
            echo -e "${RED}Clean failed${NC}"
            play_sound 1
            exit 1
        fi
        echo -e "${GREEN}Clean succeeded${NC}"
        echo ""
    fi

    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BUILD_LOG="/tmp/xcodebuild-${SCHEME}-${TIMESTAMP}.log"

    xcodebuild build \
        -workspace "$WORKSPACE" \
        -scheme "$SCHEME" \
        -destination "$DESTINATION" \
        2>&1 | tee "$BUILD_LOG" | xcbeautify
    BUILD_STATUS=${PIPESTATUS[0]}

    if [[ $BUILD_STATUS -ne 0 ]]; then
        show_error_summary "$BUILD_LOG"
        echo ""
        echo -e "${RED}Build failed (exit code: $BUILD_STATUS)${NC}"
        echo -e "${CYAN}Build log:${NC} $BUILD_LOG"
        play_sound $BUILD_STATUS
        exit $BUILD_STATUS
    fi
    show_error_summary "$BUILD_LOG"
    rm -f "$BUILD_LOG"
    play_sound 0
    exit 0
fi

# Build-run action - build and run app in simulator
if [[ "$ACTION" == "build-run" ]]; then
    echo "üöÄ Building and running: $SCHEME"
    echo "   Workspace: $WORKSPACE"
    echo "   Simulator: $IPHONE_NAME (iOS $OS_VERSION)"
    if [[ "$CLEAN" == true ]]; then
        echo "   Clean: yes"
    fi
    echo ""

    if [[ "$DRY_RUN" == true ]]; then
        if [[ "$CLEAN" == true ]]; then
            echo -e "${YELLOW}xcodebuild clean \\${NC}"
            echo -e "${YELLOW}    -workspace \"$WORKSPACE\" \\${NC}"
            echo -e "${YELLOW}    -scheme \"$SCHEME\" \\${NC}"
            echo -e "${YELLOW}    -destination \"$DESTINATION\"${NC}"
            echo ""
        fi
        echo -e "${YELLOW}xcodebuild build \\${NC}"
        echo -e "${YELLOW}    -workspace \"$WORKSPACE\" \\${NC}"
        echo -e "${YELLOW}    -scheme \"$SCHEME\" \\${NC}"
        echo -e "${YELLOW}    -destination \"$DESTINATION\" \\${NC}"
        echo -e "${YELLOW}    2>&1 | xcbeautify${NC}"
        echo ""
        echo -e "${YELLOW}# Then: boot simulator, install app, launch app${NC}"
        exit 0
    fi

    require_xcbeautify

    if [[ "$CLEAN" == true ]]; then
        echo -e "${BLUE}Cleaning...${NC}"
        xcodebuild clean \
            -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -destination "$DESTINATION" \
            2>&1 | tail -1
        if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
            echo -e "${RED}Clean failed${NC}"
            play_sound 1
            exit 1
        fi
        echo -e "${GREEN}Clean succeeded${NC}"
        echo ""
    fi

    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BUILD_LOG="/tmp/xcodebuild-${SCHEME}-${TIMESTAMP}.log"

    xcodebuild build \
        -workspace "$WORKSPACE" \
        -scheme "$SCHEME" \
        -destination "$DESTINATION" \
        2>&1 | tee "$BUILD_LOG" | xcbeautify
    BUILD_STATUS=${PIPESTATUS[0]}

    if [[ $BUILD_STATUS -ne 0 ]]; then
        show_error_summary "$BUILD_LOG"
        echo ""
        echo -e "${RED}‚ùå Build failed (exit code: $BUILD_STATUS)${NC}"
        echo ""
        echo -e "${CYAN}üìÅ Build log:${NC} $BUILD_LOG"
        play_sound $BUILD_STATUS
        exit $BUILD_STATUS
    fi
    show_error_summary "$BUILD_LOG"
    rm -f "$BUILD_LOG"

    # Fetch all build settings in one call to avoid multiple slow xcodebuild invocations
    BUILD_SETTINGS=$(xcodebuild -workspace "$WORKSPACE" -scheme "$SCHEME" -destination "$DESTINATION" -showBuildSettings 2>/dev/null)

    APP_PATH=$(echo "$BUILD_SETTINGS" | grep -m 1 "BUILT_PRODUCTS_DIR" | awk '{print $3}')
    APP_NAME=$(echo "$BUILD_SETTINGS" | grep -m 1 "FULL_PRODUCT_NAME" | awk '{print $3}')
    BUNDLE_ID=$(echo "$BUILD_SETTINGS" | grep -m 1 "PRODUCT_BUNDLE_IDENTIFIER" | awk '{print $3}')

    if [[ -z "$APP_PATH" || -z "$APP_NAME" ]]; then
        echo -e "${YELLOW}‚ö† Could not determine app path. Build succeeded but cannot auto-launch.${NC}"
        play_sound 0
        exit 0
    fi

    FULL_APP_PATH="$APP_PATH/$APP_NAME"

    # Boot simulator if needed
    DEVICE_ID=$(xcrun simctl list devices available | grep -F "    $IPHONE_NAME (" | grep -oE '[A-F0-9-]{36}' | head -1)

    if [[ -z "$DEVICE_ID" ]]; then
        echo -e "${RED}Error: Simulator '$IPHONE_NAME' not found${NC}"
        play_sound 1
        exit 1
    fi

    echo "üì± Launching simulator..."
    xcrun simctl boot "$DEVICE_ID" 2>/dev/null || true
    open -a Simulator

    # Install and launch the app
    echo "üì≤ Installing app..."
    xcrun simctl install "$DEVICE_ID" "$FULL_APP_PATH"

    echo "üöÄ Launching app..."
    if [[ -n "$BUNDLE_ID" ]]; then
        xcrun simctl launch "$DEVICE_ID" "$BUNDLE_ID"
        echo ""
        echo -e "${GREEN}‚úÖ App launched: $BUNDLE_ID${NC}"
    else
        echo -e "${YELLOW}‚ö† App installed but could not determine bundle ID to launch${NC}"
    fi

    play_sound 0
    exit 0
fi

# Run action - launch last built app (no build)
if [[ "$ACTION" == "run" ]]; then
    echo "üöÄ Launching last built app: $SCHEME"
    echo "   Workspace: $WORKSPACE"
    echo "   Simulator: $IPHONE_NAME (iOS $OS_VERSION)"
    echo ""

    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}# Boot simulator, install last built app, launch app${NC}"
        echo -e "${YELLOW}xcrun simctl boot <device-id>${NC}"
        echo -e "${YELLOW}xcrun simctl install <device-id> <app-path>${NC}"
        echo -e "${YELLOW}xcrun simctl launch <device-id> <bundle-id>${NC}"
        exit 0
    fi

    # Fetch all build settings in one call to avoid multiple slow xcodebuild invocations
    echo -e "${BLUE}üîç Reading build settings...${NC}"
    BUILD_SETTINGS=$(xcodebuild -workspace "$WORKSPACE" -scheme "$SCHEME" -destination "$DESTINATION" -showBuildSettings 2>/dev/null)

    APP_PATH=$(echo "$BUILD_SETTINGS" | grep -m 1 "BUILT_PRODUCTS_DIR" | awk '{print $3}')
    APP_NAME=$(echo "$BUILD_SETTINGS" | grep -m 1 "FULL_PRODUCT_NAME" | awk '{print $3}')
    BUNDLE_ID=$(echo "$BUILD_SETTINGS" | grep -m 1 "PRODUCT_BUNDLE_IDENTIFIER" | awk '{print $3}')

    if [[ -z "$APP_PATH" || -z "$APP_NAME" ]]; then
        echo -e "${RED}Error: Could not determine app path. Have you built the app yet?${NC}"
        echo -e "${YELLOW}Tip: Run 'build run' first${NC}"
        exit 1
    fi

    FULL_APP_PATH="$APP_PATH/$APP_NAME"

    if [[ ! -d "$FULL_APP_PATH" ]]; then
        echo -e "${RED}Error: App not found at $FULL_APP_PATH${NC}"
        echo -e "${YELLOW}Tip: Run 'build run' first${NC}"
        exit 1
    fi

    # Show app info
    if [[ "$OSTYPE" == "darwin"* ]]; then
        mod_date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$FULL_APP_PATH" 2>/dev/null)
        echo -e "${CYAN}üì¶ App:${NC} $APP_NAME"
        echo -e "${CYAN}üìÖ Built:${NC} $mod_date"
        echo ""
    fi

    # Boot simulator if needed
    DEVICE_ID=$(xcrun simctl list devices available | grep -F "    $IPHONE_NAME (" | grep -oE '[A-F0-9-]{36}' | head -1)

    if [[ -z "$DEVICE_ID" ]]; then
        echo -e "${RED}Error: Simulator '$IPHONE_NAME' not found${NC}"
        exit 1
    fi

    echo "üì± Launching simulator..."
    xcrun simctl boot "$DEVICE_ID" 2>/dev/null || true
    open -a Simulator

    # Install and launch the app
    echo "üì≤ Installing app..."
    xcrun simctl install "$DEVICE_ID" "$FULL_APP_PATH"

    echo "üöÄ Launching app..."
    if [[ -n "$BUNDLE_ID" ]]; then
        xcrun simctl launch "$DEVICE_ID" "$BUNDLE_ID"
        echo ""
        echo -e "${GREEN}‚úÖ App launched: $BUNDLE_ID${NC}"
    else
        echo -e "${YELLOW}‚ö† App installed but could not determine bundle ID to launch${NC}"
    fi

    exit 0
fi

if [[ "$DRY_RUN" == true && "$SKIP_BUILD" == true ]]; then
    echo -e "${YELLOW}xcrun xccov view --report --json <most-recent>.xcresult${NC}"
    exit 0
fi

echo "üî® Building and testing scheme: $SCHEME"
echo "   Workspace: $WORKSPACE"
echo "   Simulator: $IPHONE_NAME (iOS $OS_VERSION)"
echo "   Action: $ACTION"
if [[ -n "$ONLY_TEST" ]]; then
    echo "   Only: $ONLY_TEST"
fi

# Build the -only-testing argument if specified
ONLY_TESTING_ARG=""
if [[ -n "$ONLY_TEST" ]]; then
    ONLY_TESTING_ARG="-only-testing:$ONLY_TEST"
fi

if [[ "$DRY_RUN" == true ]]; then
    echo -e "${YELLOW}xcodebuild test \\${NC}"
    echo -e "${YELLOW}    -workspace \"$WORKSPACE\" \\${NC}"
    echo -e "${YELLOW}    -scheme \"$SCHEME\" \\${NC}"
    echo -e "${YELLOW}    -destination \"$DESTINATION\" \\${NC}"
    if [[ "$ACTION" == "coverage" ]]; then
        echo -e "${YELLOW}    -enableCodeCoverage YES \\${NC}"
        echo -e "${YELLOW}    -resultBundlePath \"/tmp/${SCHEME}-Coverage-<timestamp>.xcresult\" \\${NC}"
    fi
    if [[ -n "$ONLY_TESTING_ARG" ]]; then
        echo -e "${YELLOW}    $ONLY_TESTING_ARG \\${NC}"
    fi
    echo -e "${YELLOW}    2>&1 | xcbeautify${NC}"
    exit 0
fi

[[ "$SKIP_BUILD" != true ]] && require_xcbeautify

if [[ "$ACTION" == "coverage" ]]; then
    if [[ "$SKIP_BUILD" != true ]]; then
        # Generate result bundle in /tmp ‚Äî DerivedData will eventually clean its own copies,
        # and /tmp avoids cluttering the project directory
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        XCRESULT_PATH="/tmp/${SCHEME}-Coverage-${TIMESTAMP}.xcresult"
        BUILD_LOG="/tmp/xcodebuild-${SCHEME}-${TIMESTAMP}.log"
        echo "   xcresult: $XCRESULT_PATH"
        echo ""

        if [[ -n "$ONLY_TESTING_ARG" ]]; then
            xcodebuild test \
                -workspace "$WORKSPACE" \
                -scheme "$SCHEME" \
                -destination "$DESTINATION" \
                -enableCodeCoverage YES \
                -resultBundlePath "$XCRESULT_PATH" \
                $ONLY_TESTING_ARG \
                2>&1 | tee "$BUILD_LOG" | xcbeautify
        else
            xcodebuild test \
                -workspace "$WORKSPACE" \
                -scheme "$SCHEME" \
                -destination "$DESTINATION" \
                -enableCodeCoverage YES \
                -resultBundlePath "$XCRESULT_PATH" \
                2>&1 | tee "$BUILD_LOG" | xcbeautify
        fi
        BUILD_STATUS=${PIPESTATUS[0]}

        if [[ $BUILD_STATUS -eq 0 ]]; then
            show_error_summary "$BUILD_LOG"
            rm -f "$BUILD_LOG"
        elif [[ $BUILD_STATUS -eq 65 ]]; then
            show_error_summary "$BUILD_LOG" true
            rm -f "$BUILD_LOG"
            echo ""
            echo -e "${RED}‚ùå Tests failed${NC}"
        else
            show_error_summary "$BUILD_LOG"
            rm -f "$BUILD_LOG"
            echo ""
            echo -e "${RED}‚ùå Build failed (exit code: $BUILD_STATUS)${NC}"
        fi
    fi

    # Extract and display coverage report
    echo ""
    coverage_json=$(extract_coverage "$XCRESULT_PATH")

    if [[ -n "$coverage_json" ]]; then
        coverage_filter=""
        if [[ "$FILTER_SCHEME" == true ]]; then
            coverage_filter="${SCHEME:-}"
        elif [[ -n "${FILTER:-}" ]]; then
            coverage_filter="$FILTER"
        fi

        format_summary "$coverage_json" "$XCRESULT_PATH" "$coverage_filter"

        if [[ "$DETAILED" == true ]]; then
            format_detailed "$coverage_json" "$coverage_filter"
        fi
    else
        echo -e "${YELLOW}‚ö† No coverage data found in .xcresult${NC}"
        echo -e "${YELLOW}Make sure tests were run with code coverage enabled.${NC}"
        if [[ "$SKIP_BUILD" == true ]]; then
            exit 1
        fi
    fi

    echo ""
    echo -e "${CYAN}üìÅ Full results:${NC} $XCRESULT_PATH"
    echo -e "${CYAN}   View in Xcode:${NC} open $XCRESULT_PATH"
    [[ "$SKIP_BUILD" == true ]] && exit 0
else
    # Test action - simple test run without coverage
    BUILD_LOG="/tmp/xcodebuild-${SCHEME}-$(date +%Y%m%d_%H%M%S).log"
    echo ""

    if [[ -n "$ONLY_TESTING_ARG" ]]; then
        xcodebuild test \
            -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -destination "$DESTINATION" \
            $ONLY_TESTING_ARG \
            2>&1 | tee "$BUILD_LOG" | xcbeautify
    else
        xcodebuild test \
            -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -destination "$DESTINATION" \
            2>&1 | tee "$BUILD_LOG" | xcbeautify
    fi
    BUILD_STATUS=${PIPESTATUS[0]}

    if [[ $BUILD_STATUS -eq 0 ]]; then
        show_error_summary "$BUILD_LOG"
        rm -f "$BUILD_LOG"
    elif [[ $BUILD_STATUS -eq 65 ]]; then
        show_error_summary "$BUILD_LOG" true
        rm -f "$BUILD_LOG"
        echo ""
        echo -e "${RED}‚ùå Tests failed${NC}"
    else
        show_error_summary "$BUILD_LOG"
        rm -f "$BUILD_LOG"
        echo ""
        echo -e "${RED}‚ùå Build failed (exit code: $BUILD_STATUS)${NC}"
    fi
fi

play_sound $BUILD_STATUS
exit $BUILD_STATUS
